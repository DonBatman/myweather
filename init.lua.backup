-- Load Settings from settingtypes.txt
local settings = minetest.settings
local part_mult = settings:get("myweather_particle_multiplier") or 1.0
local wind_push = settings:get("myweather_wind_push_strength") or 1.0
local use_sound = settings:get_bool("myweather_enable_sound") ~= false

myweather = {}

-- Apply them to our global table
myweather.config = {
	part_mult = tonumber(part_mult),
	wind_push = tonumber(wind_push),
	use_sound = use_sound,
}

-- MyWeather Standalone Mod
myweather.current_system = "clear"
myweather.damage_enabled = true
myweather.wind_dir = {x = 0, z = 0}
myweather.sounds = {}

-- Load Files
local path = minetest.get_modpath("myweather")
dofile(path .. "/nodes.lua")
dofile(path .. "/tools.lua")
dofile(path .. "/commands.lua")

-- Initial Wind Setup
function myweather.update_wind()
	myweather.wind_dir.x = (math.random() - 0.5) * 0.8
	myweather.wind_dir.z = (math.random() - 0.5) * 0.8
end
myweather.update_wind()

-- BIOME-SPECIFIC WEATHER LOGIC
local function get_local_weather(pos)
	local global = myweather.current_system
	
	if global == "snow" or global == "snowstorm" or global == "sandstorm" or global == "hail" then 
		return global 
	end
	if global == "clear" then return "clear" end

	local data = minetest.get_biome_data(pos)
	if not data then return global end
	local heat, humidity = data.heat, data.humidity

	if heat > 70 and humidity < 30 then
		return (global == "storm") and "sandstorm" or "clear"
	end

	if heat < 35 then 
		return (global == "rain") and "snow" or "snowstorm"
	end

	if global == "storm" and heat >= 35 and heat <= 45 then
		return "hail"
	end
	
	return global
end

-- 1. WEATHER CYCLES & LIGHTNING
local timer = 0
minetest.register_globalstep(function(dtime)
	timer = timer + dtime
	if timer < 8 then return end
	timer = 0

	local rng = math.random(1, 100)
	if myweather.current_system == "clear" and rng < 8 then
		myweather.current_system = "rain"
		myweather.update_wind()
	elseif myweather.current_system ~= "clear" and rng < 12 then
		myweather.current_system = "clear"
	end

	for _, player in ipairs(minetest.get_connected_players()) do
		local ppos = player:get_pos()
		local ray = minetest.line_of_sight({x=ppos.x, y=ppos.y+1.5, z=ppos.z}, {x=ppos.x, y=ppos.y+30, z=ppos.z})
		local local_w = get_local_weather(ppos)

		if myweather.current_system == "storm" and math.random(1, 10) == 1 then
			minetest.sound_play("myweather_thunder", {pos = ppos, gain = 1.0, max_hear_distance = 128})
			player:set_sky({base_color = "#ffffff", type = "plain"})
			minetest.after(0.2, function()
				local p = minetest.get_player_by_name(player:get_player_name())
				if p then p:set_sky({base_color = "#444444", type = "plain", fog = { distance = 45 }}) end
			end)
		end

		if local_w == "hail" and ray == true then
			local inv = player:get_inventory()
			local armor = inv:get_list("armor")
			local has_helmet = (armor and armor[1] and not armor[1]:is_empty())
			if not has_helmet then
				player:set_hp(player:get_hp() - 1)
			end
		end
	end
end)

-- 2. ABM: WEATHER DEVICES
minetest.register_abm({
	label = "Weather Devices Update",
	nodenames = {"myweather:wind_vane", "group:watch_weather"},
	interval = 2,
	chance = 1,
	action = function(pos, node)
		if node.name == "myweather:wind_vane" then
			local dir = 0
			if math.abs(myweather.wind_dir.x) > math.abs(myweather.wind_dir.z) then
				dir = (myweather.wind_dir.x > 0) and 1 or 3
			else
				dir = (myweather.wind_dir.z > 0) and 0 or 2
			end
			minetest.swap_node(pos, {name = node.name, param2 = dir})
		else
			local meta = minetest.get_meta(pos)
			local data = minetest.get_biome_data(pos)
			local raw_heat = data and data.heat or 50
			local heat = math.floor((raw_heat * 0.6) - 20) or "N/A"
			local humidity = data and math.floor(data.humidity) or "N/A"
			local wind_speed = math.floor(math.abs(myweather.wind_dir.x + myweather.wind_dir.z) * 60)
			
			meta:set_string("infotext", 
				"--- Weather Station ---\n" ..
				"System: " .. myweather.current_system:upper() .. "\n" ..
				"Temp: " .. heat .. "Â°C | Humid: " .. humidity .. "%\n" ..
				"Wind: " .. wind_speed .. " knots"
			)
		end
	end,
})

-- 3. VISUAL EFFECTS, PARTICLES, PHYSICS & SOUND
local effect_t = 0
minetest.register_globalstep(function(dtime)
	effect_t = effect_t + dtime
	if effect_t < 0.1 then return end
	effect_t = 0

	for _, player in ipairs(minetest.get_connected_players()) do
		local ppos = player:get_pos()
		local name = player:get_player_name()
		
		local ray = minetest.line_of_sight({x=ppos.x, y=ppos.y+1.5, z=ppos.z}, {x=ppos.x, y=ppos.y+20, z=ppos.z})
		local local_w = get_local_weather(ppos)
		local is_sheltered = (ray == false)

		-- --- SOUND LOGIC ---
		if local_w == "rain" or local_w == "storm" then
			if not myweather.sounds[name] then
				-- Start the looping rain sound
				myweather.sounds[name] = minetest.sound_play("myweather_rain", {
					to_player = name,
					gain = is_sheltered and 0.2 or 0.6, -- Muffled sound if inside
					loop = true,
				})
			else
				-- Update volume dynamically (muffle if player walks inside)
				minetest.sound_fade(myweather.sounds[name], 0.5, is_sheltered and 0.2 or 0.6)
			end
		else
			-- If weather is clear or snow, stop the rain sound
			if myweather.sounds[name] then
				minetest.sound_stop(myweather.sounds[name])
				myweather.sounds[name] = nil
			end
		end

		-- --- VISUALS & PHYSICS (Existing) ---
		if local_w ~= "clear" then
			local is_storm = (local_w == "storm" or local_w == "snowstorm" or local_w == "sandstorm" or local_w == "hail")
			local is_snow = local_w:find("snow")
			local is_sand = (local_w == "sandstorm")
			
			if not is_sheltered then
				local wind_mult = (is_storm and 0.45 or 0.1) * myweather.config.wind_push

				player:add_velocity({x = myweather.wind_dir.x * wind_mult, y = 0, z = myweather.wind_dir.z * wind_mult})
			end

			local amount = 100
			if local_w == "rain" then amount = 400
			elseif local_w == "storm" then amount = 1200
			elseif local_w == "snow" then amount = 200
			elseif local_w == "snowstorm" then amount = 800
			elseif local_w == "hail" then amount = 400
			elseif local_w == "sandstorm" then amount = 800 end
			
			amount = is_sheltered and math.floor(amount * 0.25) or amount
			local texture = (local_w == "hail") and "myweather_hail.png" or (is_sand and "myweather_sand.png" or (is_snow and "myweather_snow.png" or "myweather_rain.png"))
			local vel_y = is_snow and (is_storm and -10 or -5) or -22
			local spread = 15 
			
			minetest.add_particlespawner({
				amount = amount, time = 0.1,
				minpos = {x=ppos.x - spread, y=ppos.y + 6, z=ppos.z - spread},
				maxpos = {x=ppos.x + spread, y=ppos.y + 12, z=ppos.z + spread},
				minvel = {x=myweather.wind_dir.x*30, y=vel_y, z=myweather.wind_dir.z*30},
				maxvel = {x=myweather.wind_dir.x*40, y=vel_y-4, z=myweather.wind_dir.z*40},
				minexptime = is_snow and 3.0 or 0.8, maxexptime = is_snow and 4.0 or 1.2,
				minsize = 2, maxsize = is_storm and 6 or 4,
				texture = texture, playername = name,
				vertical = not (is_sand or local_w == "hail" or is_snow),
				collisiondetection = true, collision_removal = true,
			})

			player:set_sky({
				base_color = is_storm and "#111111" or "#556677", 
				type = "plain", clouds = false,
				fog = { distance = is_storm and 25 or 45 } 
			})
		else
			player:set_sky({base_color = "#8cbafa", type = "regular"})
		end
	end
end)

-- 4. ACCUMULATION & MELTING
minetest.register_abm({
	label = "Weather Accumulation and Melting",
	-- We add dirt and grass to the list of nodes that can "catch" snow
	nodenames = {
		"group:melt_speed", "group:solid", "group:snowy", "group:barrel", 
		"group:myweather_clearable", "default:dirt_with_grass", "default:dirt", "default:sand"
	},
	interval = 20, -- Slightly faster check
	chance = 5,
	action = function(pos, node)
		local local_w = get_local_weather(pos)
		local light = minetest.get_node_light(pos) or 0
		
		-- 1. MELTING LOGIC
		if myweather.current_system == "clear" and light >= 13 then
			if node.name:find("myweather:snow_cover_") then
				local level = tonumber(node.name:sub(-1))
				if level and level > 1 then 
					minetest.swap_node(pos, {name = "myweather:snow_cover_" .. (level - 1)})
				else 
					minetest.remove_node(pos) 
				end
			elseif node.name == "myweather:puddle" then 
				minetest.remove_node(pos) 
			end
			return
		end

		-- 2. ACCUMULATION LOGIC (Only if light is high enough - i.e., it can see the sky)
		if light >= 14 then
			local pos_above = {x=pos.x, y=pos.y+1, z=pos.z}
			local node_above = minetest.get_node(pos_above).name

			if local_w:find("snow") then
				-- If we hit an existing snow cover, make it thicker
				if node.name:find("myweather:snow_cover_") then
					local level = tonumber(node.name:sub(-1))
					if level and level < 5 then 
						minetest.set_node(pos, {name="myweather:snow_cover_" .. (level + 1)}) 
					end
				-- If we hit the ground and air is above, place the first layer
				elseif node_above == "air" then
					minetest.set_node(pos_above, {name="myweather:snow_cover_1"})
				end
				
			elseif local_w == "rain" or local_w == "storm" then
				-- Barrel filling logic
				if node.name:find("myweather:barrel_") then
					local lvl = tonumber(node.name:sub(-1))
					if lvl and lvl < 4 then 
						minetest.set_node(pos, {name="myweather:barrel_" .. (lvl + 1)}) 
					end
				end
			end
		end
	end,
})
